/*
 * Machines API
 * # Introduction  Fly Machines are the compute behind the Fly.io platform. They are fast-launching VMs that can be started and stopped at subsecond speeds. A Machine is the configuration and state for a single VM running on our platform. Every Machine will belong to a Fly App; Apps can have more than one Machine. Read more [here](https://fly.io/docs/machines/).  The Machines REST API allows you to provison and manage Apps, Machines and Volumes on the Fly.io platform. To manage other Fly.io resources like organizations, use the [GraphQL API](https://fly.io/docs/networking/custom-domains-with-fly/#graphql-api-notes).  ## Authentication  All requests must include the Fly API Token in the HTTP Headers as follows:  ``` Authorization: Bearer [TOKEN] ```  You can get your API token using [flyctl](https://fly.io/docs/hands-on/install-flyctl/) by running `fly auth token`  ## Base URL  The easiest (and recommended) way to connect to the Machines API is to use the public `api.machines.dev` endpoint, a simpler and more performant alternative to connecting over WireGuard. You can still access your Machines directly over a WireGuard VPN, and use the private Machines API endpoint: `http://_api.internal:4280`. This method requires more setup.  Follow the [instructions](https://fly.io/docs/networking/private-networking/#private-network-vpn) to set up a permanent WireGuard connection to your Fly.io [IPv6 private network](https://fly.io/docs/networking/private-networking/). Once you’re connected, Fly internal DNS should expose the Machines API endpoint at: `http://_api.internal:4280`  ## Response Codes  The API uses conventional HTTP status codes to signal whether a request was successful or not.  Typically, 2xx HTTP status codes denote successful operations, 4xx codes imply failures related to the user, and 5xx codes suggest problems with the infrastructure.  | Status | Description                                 | | :----: | ------------------------------------------- | | `200`  | Successful request.                         | | `201`  | Created successfully.                       | | `202`  | Successful request. No content.             | | `400`  | Check that the parameters were correct.     | | `401`  | The API key used was missing or invalid.    | | `404`  | The resource was not found.                 | | `5xx`  | Indicates an error with Fly.io API servers. | 
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.fly.sdk;

import io.fly.client.model.CreateLeaseRequest;
import io.fly.client.model.CreateMachineRequest;
import io.fly.client.model.ErrorResponse;
import io.fly.client.model.Lease;
import io.fly.client.model.Machine;
import io.fly.client.model.MachineEvent;
import io.fly.client.model.MachineExecRequest;
import io.fly.client.model.MachineVersion;
import io.fly.client.model.ProcessStat;
import io.fly.client.model.SignalRequest;
import io.fly.client.model.StopRequest;
import io.fly.client.model.UpdateMachineRequest;
import org.junit.Test;
import org.junit.Ignore;

import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for MachinesApi
 */
@Ignore
public class MachinesApiTest {

    private final MachinesApi api = new MachinesApi();

    
    /**
     * Cordon Machine
     *
     * “Cordoning” a Machine refers to disabling its services, so the Fly Proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of Machines is started up with services disabled, and when they are all healthy, the services are enabled on the new Machines and disabled on the old ones. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesCordonTest() {
        String appName = null;
        String machineId = null;

        api.machinesCordon(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * Create Machine
     *
     * Create a Machine within a specific app using the details provided in the request body.  **Important**: This request can fail, and you’re responsible for handling that failure. If you ask for a large Machine, or a Machine in a region we happen to be at capacity for, you might need to retry the request, or to fall back to another region. If you’re working directly with the Machines API, you’re taking some responsibility for your own orchestration! 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesCreateTest() {
        String appName = null;
        CreateMachineRequest request = null;

        Machine response = api.machinesCreate(appName, request);

        // TODO: test validations
    }
    
    /**
     * Create Lease
     *
     * Create a lease for a specific Machine within an app using the details provided in the request body. Machine leases can be used to obtain an exclusive lock on modifying a Machine. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesCreateLeaseTest() {
        String appName = null;
        String machineId = null;
        CreateLeaseRequest request = null;

        Lease response = api.machinesCreateLease(appName, machineId, request);

        // TODO: test validations
    }
    
    /**
     * Destroy Machine
     *
     * Delete a specific Machine within an app by Machine ID, with an optional force parameter to force kill the Machine if it&#39;s running. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesDeleteTest() {
        String appName = null;
        String machineId = null;
        Boolean force = null;

        api.machinesDelete(appName, machineId, force);

        // TODO: test validations
    }
    
    /**
     * Delete Metadata
     *
     * Delete metadata for a specific Machine within an app by providing a metadata key. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesDeleteMetadataTest() {
        String appName = null;
        String machineId = null;
        String key = null;

        api.machinesDeleteMetadata(appName, machineId, key);

        // TODO: test validations
    }
    
    /**
     * Execute Command
     *
     * Execute a command on a specific Machine and return the raw command output bytes. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesExecTest() {
        String appName = null;
        String machineId = null;
        MachineExecRequest request = null;

        String response = api.machinesExec(appName, machineId, request);

        // TODO: test validations
    }
    
    /**
     * List Machines
     *
     * List all Machines associated with a specific app, with optional filters for including deleted Machines and filtering by region. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesListTest() {
        String appName = null;
        Boolean includeDeleted = null;
        String region = null;

        List<Machine> response = api.machinesList(appName, includeDeleted, region);

        // TODO: test validations
    }
    
    /**
     * List Events
     *
     * List all events associated with a specific Machine within an app. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesListEventsTest() {
        String appName = null;
        String machineId = null;

        List<MachineEvent> response = api.machinesListEvents(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * List Processes
     *
     * List all processes running on a specific Machine within an app, with optional sorting parameters. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesListProcessesTest() {
        String appName = null;
        String machineId = null;
        String sortBy = null;
        String order = null;

        List<ProcessStat> response = api.machinesListProcesses(appName, machineId, sortBy, order);

        // TODO: test validations
    }
    
    /**
     * List Versions
     *
     * List all versions of the configuration for a specific Machine within an app. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesListVersionsTest() {
        String appName = null;
        String machineId = null;

        List<MachineVersion> response = api.machinesListVersions(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * Release Lease
     *
     * Release the lease of a specific Machine within an app. Machine leases can be used to obtain an exclusive lock on modifying a Machine. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesReleaseLeaseTest() {
        String appName = null;
        String machineId = null;

        api.machinesReleaseLease(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * Restart Machine
     *
     * Restart a specific Machine within an app, with an optional timeout parameter. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesRestartTest() {
        String appName = null;
        String machineId = null;
        String timeout = null;

        api.machinesRestart(appName, machineId, timeout);

        // TODO: test validations
    }
    
    /**
     * Get Machine
     *
     * Get details of a specific Machine within an app by the Machine ID. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesShowTest() {
        String appName = null;
        String machineId = null;

        Machine response = api.machinesShow(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * Get Lease
     *
     * Retrieve the current lease of a specific Machine within an app. Machine leases can be used to obtain an exclusive lock on modifying a Machine. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesShowLeaseTest() {
        String appName = null;
        String machineId = null;

        Lease response = api.machinesShowLease(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * Get Metadata
     *
     * Retrieve metadata for a specific Machine within an app. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesShowMetadataTest() {
        String appName = null;
        String machineId = null;

        Map<String, String> response = api.machinesShowMetadata(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * Signal Machine
     *
     * Send a signal to a specific Machine within an app using the details provided in the request body. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesSignalTest() {
        String appName = null;
        String machineId = null;
        SignalRequest request = null;

        api.machinesSignal(appName, machineId, request);

        // TODO: test validations
    }
    
    /**
     * Start Machine
     *
     * Start a specific Machine within an app. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesStartTest() {
        String appName = null;
        String machineId = null;

        api.machinesStart(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * Stop Machine
     *
     * Stop a specific Machine within an app, with an optional request body to specify signal and timeout. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesStopTest() {
        String appName = null;
        String machineId = null;
        StopRequest request = null;

        api.machinesStop(appName, machineId, request);

        // TODO: test validations
    }
    
    /**
     * Uncordon Machine
     *
     * “Cordoning” a Machine refers to disabling its services, so the Fly Proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of Machines is started up with services disabled, and when they are all healthy, the services are enabled on the new Machines and disabled on the old ones. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesUncordonTest() {
        String appName = null;
        String machineId = null;

        api.machinesUncordon(appName, machineId);

        // TODO: test validations
    }
    
    /**
     * Update Machine
     *
     * Update a Machine&#39;s configuration using the details provided in the request body. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesUpdateTest() {
        String appName = null;
        String machineId = null;
        UpdateMachineRequest request = null;

        Machine response = api.machinesUpdate(appName, machineId, request);

        // TODO: test validations
    }
    
    /**
     * Update Metadata
     *
     * Update metadata for a specific machine within an app by providing a metadata key. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesUpdateMetadataTest() {
        String appName = null;
        String machineId = null;
        String key = null;

        api.machinesUpdateMetadata(appName, machineId, key);

        // TODO: test validations
    }
    
    /**
     * Wait for State
     *
     * Wait for a Machine to reach a specific state. Specify the desired state with the state parameter. See the [Machine states table](https://fly.io/docs/machines/working-with-machines/#machine-states) for a list of possible states. The default for this parameter is &#x60;started&#x60;.  This request will block for up to 60 seconds. Set a shorter timeout with the timeout parameter. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void machinesWaitTest() {
        String appName = null;
        String machineId = null;
        String instanceId = null;
        Integer timeout = null;
        String state = null;

        api.machinesWait(appName, machineId, instanceId, timeout, state);

        // TODO: test validations
    }
    
}
