/*
Machines API

# Introduction  Fly Machines are the compute behind the Fly.io platform. They are fast-launching VMs that can be started and stopped at subsecond speeds. A Machine is the configuration and state for a single VM running on our platform. Every Machine will belong to a Fly App; Apps can have more than one Machine. Read more [here](https://fly.io/docs/machines/).  The Machines REST API allows you to provison and manage Apps, Machines and Volumes on the Fly.io platform. To manage other Fly.io resources like organizations, use the [GraphQL API](https://fly.io/docs/networking/custom-domains-with-fly/#graphql-api-notes).  ## Authentication  All requests must include the Fly API Token in the HTTP Headers as follows:  ``` Authorization: Bearer [TOKEN] ```  You can get your API token using [flyctl](https://fly.io/docs/hands-on/install-flyctl/) by running `fly auth token`  ## Base URL  The easiest (and recommended) way to connect to the Machines API is to use the public `api.machines.dev` endpoint, a simpler and more performant alternative to connecting over WireGuard. You can still access your Machines directly over a WireGuard VPN, and use the private Machines API endpoint: `http://_api.internal:4280`. This method requires more setup.  Follow the [instructions](https://fly.io/docs/networking/private-networking/#private-network-vpn) to set up a permanent WireGuard connection to your Fly.io [IPv6 private network](https://fly.io/docs/networking/private-networking/). Once you’re connected, Fly internal DNS should expose the Machines API endpoint at: `http://_api.internal:4280`  ## Response Codes  The API uses conventional HTTP status codes to signal whether a request was successful or not.  Typically, 2xx HTTP status codes denote successful operations, 4xx codes imply failures related to the user, and 5xx codes suggest problems with the infrastructure.  | Status | Description                                 | | :----: | ------------------------------------------- | | `200`  | Successful request.                         | | `201`  | Created successfully.                       | | `202`  | Successful request. No content.             | | `400`  | Check that the parameters were correct.     | | `401`  | The API key used was missing or invalid.    | | `404`  | The resource was not found.                 | | `5xx`  | Indicates an error with Fly.io API servers. | 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fly-sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MachinesAPIService MachinesAPI service
type MachinesAPIService service

type ApiMachinesCordonRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesCordonRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesCordonExecute(r)
}

/*
MachinesCordon Cordon Machine

“Cordoning” a Machine refers to disabling its services, so the Fly Proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of Machines is started up with services disabled, and when they are all healthy, the services are enabled on the new Machines and disabled on the old ones.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesCordonRequest
*/
func (a *MachinesAPIService) MachinesCordon(ctx context.Context, appName string, machineId string) ApiMachinesCordonRequest {
	return ApiMachinesCordonRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesCordonExecute(r ApiMachinesCordonRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesCordon")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/cordon"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesCreateRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	request *CreateMachineRequest
}

// Create machine request
func (r ApiMachinesCreateRequest) Request(request CreateMachineRequest) ApiMachinesCreateRequest {
	r.request = &request
	return r
}

func (r ApiMachinesCreateRequest) Execute() (*Machine, *http.Response, error) {
	return r.ApiService.MachinesCreateExecute(r)
}

/*
MachinesCreate Create Machine

Create a Machine within a specific app using the details provided in the request body.

**Important**: This request can fail, and you’re responsible for handling that failure. If you ask for a large Machine, or a Machine in a region we happen to be at capacity for, you might need to retry the request, or to fall back to another region. If you’re working directly with the Machines API, you’re taking some responsibility for your own orchestration!


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @return ApiMachinesCreateRequest
*/
func (a *MachinesAPIService) MachinesCreate(ctx context.Context, appName string) ApiMachinesCreateRequest {
	return ApiMachinesCreateRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
//  @return Machine
func (a *MachinesAPIService) MachinesCreateExecute(r ApiMachinesCreateRequest) (*Machine, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Machine
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesCreateLeaseRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	request *CreateLeaseRequest
}

// Request body
func (r ApiMachinesCreateLeaseRequest) Request(request CreateLeaseRequest) ApiMachinesCreateLeaseRequest {
	r.request = &request
	return r
}

func (r ApiMachinesCreateLeaseRequest) Execute() (*Lease, *http.Response, error) {
	return r.ApiService.MachinesCreateLeaseExecute(r)
}

/*
MachinesCreateLease Create Lease

Create a lease for a specific Machine within an app using the details provided in the request body. Machine leases can be used to obtain an exclusive lock on modifying a Machine.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesCreateLeaseRequest
*/
func (a *MachinesAPIService) MachinesCreateLease(ctx context.Context, appName string, machineId string) ApiMachinesCreateLeaseRequest {
	return ApiMachinesCreateLeaseRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return Lease
func (a *MachinesAPIService) MachinesCreateLeaseExecute(r ApiMachinesCreateLeaseRequest) (*Lease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Lease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesCreateLease")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/lease"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesDeleteRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	force *bool
}

// Force kill the machine if it&#39;s running
func (r ApiMachinesDeleteRequest) Force(force bool) ApiMachinesDeleteRequest {
	r.force = &force
	return r
}

func (r ApiMachinesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesDeleteExecute(r)
}

/*
MachinesDelete Destroy Machine

Delete a specific Machine within an app by Machine ID, with an optional force parameter to force kill the Machine if it's running.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesDeleteRequest
*/
func (a *MachinesAPIService) MachinesDelete(ctx context.Context, appName string, machineId string) ApiMachinesDeleteRequest {
	return ApiMachinesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesDeleteExecute(r ApiMachinesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesDeleteMetadataRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	key string
}

func (r ApiMachinesDeleteMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesDeleteMetadataExecute(r)
}

/*
MachinesDeleteMetadata Delete Metadata

Delete metadata for a specific Machine within an app by providing a metadata key.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @param key Metadata Key
 @return ApiMachinesDeleteMetadataRequest
*/
func (a *MachinesAPIService) MachinesDeleteMetadata(ctx context.Context, appName string, machineId string, key string) ApiMachinesDeleteMetadataRequest {
	return ApiMachinesDeleteMetadataRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
		key: key,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesDeleteMetadataExecute(r ApiMachinesDeleteMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesDeleteMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/metadata/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesExecRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	request *MachineExecRequest
}

// Request body
func (r ApiMachinesExecRequest) Request(request MachineExecRequest) ApiMachinesExecRequest {
	r.request = &request
	return r
}

func (r ApiMachinesExecRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MachinesExecExecute(r)
}

/*
MachinesExec Execute Command

Execute a command on a specific Machine and return the raw command output bytes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesExecRequest
*/
func (a *MachinesAPIService) MachinesExec(ctx context.Context, appName string, machineId string) ApiMachinesExecRequest {
	return ApiMachinesExecRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return string
func (a *MachinesAPIService) MachinesExecExecute(r ApiMachinesExecRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesExec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/exec"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesListRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	includeDeleted *bool
	region *string
}

// Include deleted machines
func (r ApiMachinesListRequest) IncludeDeleted(includeDeleted bool) ApiMachinesListRequest {
	r.includeDeleted = &includeDeleted
	return r
}

// Region filter
func (r ApiMachinesListRequest) Region(region string) ApiMachinesListRequest {
	r.region = &region
	return r
}

func (r ApiMachinesListRequest) Execute() ([]Machine, *http.Response, error) {
	return r.ApiService.MachinesListExecute(r)
}

/*
MachinesList List Machines

List all Machines associated with a specific app, with optional filters for including deleted Machines and filtering by region.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @return ApiMachinesListRequest
*/
func (a *MachinesAPIService) MachinesList(ctx context.Context, appName string) ApiMachinesListRequest {
	return ApiMachinesListRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
//  @return []Machine
func (a *MachinesAPIService) MachinesListExecute(r ApiMachinesListRequest) ([]Machine, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Machine
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_deleted", r.includeDeleted, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesListEventsRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesListEventsRequest) Execute() ([]MachineEvent, *http.Response, error) {
	return r.ApiService.MachinesListEventsExecute(r)
}

/*
MachinesListEvents List Events

List all events associated with a specific Machine within an app.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesListEventsRequest
*/
func (a *MachinesAPIService) MachinesListEvents(ctx context.Context, appName string, machineId string) ApiMachinesListEventsRequest {
	return ApiMachinesListEventsRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return []MachineEvent
func (a *MachinesAPIService) MachinesListEventsExecute(r ApiMachinesListEventsRequest) ([]MachineEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MachineEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesListEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesListProcessesRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	sortBy *string
	order *string
}

// Sort by
func (r ApiMachinesListProcessesRequest) SortBy(sortBy string) ApiMachinesListProcessesRequest {
	r.sortBy = &sortBy
	return r
}

// Order
func (r ApiMachinesListProcessesRequest) Order(order string) ApiMachinesListProcessesRequest {
	r.order = &order
	return r
}

func (r ApiMachinesListProcessesRequest) Execute() ([]ProcessStat, *http.Response, error) {
	return r.ApiService.MachinesListProcessesExecute(r)
}

/*
MachinesListProcesses List Processes

List all processes running on a specific Machine within an app, with optional sorting parameters.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesListProcessesRequest
*/
func (a *MachinesAPIService) MachinesListProcesses(ctx context.Context, appName string, machineId string) ApiMachinesListProcessesRequest {
	return ApiMachinesListProcessesRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return []ProcessStat
func (a *MachinesAPIService) MachinesListProcessesExecute(r ApiMachinesListProcessesRequest) ([]ProcessStat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProcessStat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesListProcesses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/ps"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesListVersionsRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesListVersionsRequest) Execute() ([]MachineVersion, *http.Response, error) {
	return r.ApiService.MachinesListVersionsExecute(r)
}

/*
MachinesListVersions List Versions

List all versions of the configuration for a specific Machine within an app.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesListVersionsRequest
*/
func (a *MachinesAPIService) MachinesListVersions(ctx context.Context, appName string, machineId string) ApiMachinesListVersionsRequest {
	return ApiMachinesListVersionsRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return []MachineVersion
func (a *MachinesAPIService) MachinesListVersionsExecute(r ApiMachinesListVersionsRequest) ([]MachineVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MachineVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesListVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesReleaseLeaseRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesReleaseLeaseRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesReleaseLeaseExecute(r)
}

/*
MachinesReleaseLease Release Lease

Release the lease of a specific Machine within an app. Machine leases can be used to obtain an exclusive lock on modifying a Machine.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesReleaseLeaseRequest
*/
func (a *MachinesAPIService) MachinesReleaseLease(ctx context.Context, appName string, machineId string) ApiMachinesReleaseLeaseRequest {
	return ApiMachinesReleaseLeaseRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesReleaseLeaseExecute(r ApiMachinesReleaseLeaseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesReleaseLease")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/lease"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesRestartRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	timeout *string
}

// Restart timeout as a Go duration string or number of seconds
func (r ApiMachinesRestartRequest) Timeout(timeout string) ApiMachinesRestartRequest {
	r.timeout = &timeout
	return r
}

func (r ApiMachinesRestartRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesRestartExecute(r)
}

/*
MachinesRestart Restart Machine

Restart a specific Machine within an app, with an optional timeout parameter.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesRestartRequest
*/
func (a *MachinesAPIService) MachinesRestart(ctx context.Context, appName string, machineId string) ApiMachinesRestartRequest {
	return ApiMachinesRestartRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesRestartExecute(r ApiMachinesRestartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesRestart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesShowRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesShowRequest) Execute() (*Machine, *http.Response, error) {
	return r.ApiService.MachinesShowExecute(r)
}

/*
MachinesShow Get Machine

Get details of a specific Machine within an app by the Machine ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesShowRequest
*/
func (a *MachinesAPIService) MachinesShow(ctx context.Context, appName string, machineId string) ApiMachinesShowRequest {
	return ApiMachinesShowRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return Machine
func (a *MachinesAPIService) MachinesShowExecute(r ApiMachinesShowRequest) (*Machine, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Machine
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesShow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesShowLeaseRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesShowLeaseRequest) Execute() (*Lease, *http.Response, error) {
	return r.ApiService.MachinesShowLeaseExecute(r)
}

/*
MachinesShowLease Get Lease

Retrieve the current lease of a specific Machine within an app. Machine leases can be used to obtain an exclusive lock on modifying a Machine.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesShowLeaseRequest
*/
func (a *MachinesAPIService) MachinesShowLease(ctx context.Context, appName string, machineId string) ApiMachinesShowLeaseRequest {
	return ApiMachinesShowLeaseRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return Lease
func (a *MachinesAPIService) MachinesShowLeaseExecute(r ApiMachinesShowLeaseRequest) (*Lease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Lease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesShowLease")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/lease"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesShowMetadataRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesShowMetadataRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.MachinesShowMetadataExecute(r)
}

/*
MachinesShowMetadata Get Metadata

Retrieve metadata for a specific Machine within an app.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesShowMetadataRequest
*/
func (a *MachinesAPIService) MachinesShowMetadata(ctx context.Context, appName string, machineId string) ApiMachinesShowMetadataRequest {
	return ApiMachinesShowMetadataRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *MachinesAPIService) MachinesShowMetadataExecute(r ApiMachinesShowMetadataRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesShowMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesSignalRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	request *SignalRequest
}

// Request body
func (r ApiMachinesSignalRequest) Request(request SignalRequest) ApiMachinesSignalRequest {
	r.request = &request
	return r
}

func (r ApiMachinesSignalRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesSignalExecute(r)
}

/*
MachinesSignal Signal Machine

Send a signal to a specific Machine within an app using the details provided in the request body.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesSignalRequest
*/
func (a *MachinesAPIService) MachinesSignal(ctx context.Context, appName string, machineId string) ApiMachinesSignalRequest {
	return ApiMachinesSignalRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesSignalExecute(r ApiMachinesSignalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesSignal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/signal"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesStartRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesStartRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesStartExecute(r)
}

/*
MachinesStart Start Machine

Start a specific Machine within an app.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesStartRequest
*/
func (a *MachinesAPIService) MachinesStart(ctx context.Context, appName string, machineId string) ApiMachinesStartRequest {
	return ApiMachinesStartRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesStartExecute(r ApiMachinesStartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesStart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesStopRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	request *StopRequest
}

// Optional request body
func (r ApiMachinesStopRequest) Request(request StopRequest) ApiMachinesStopRequest {
	r.request = &request
	return r
}

func (r ApiMachinesStopRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesStopExecute(r)
}

/*
MachinesStop Stop Machine

Stop a specific Machine within an app, with an optional request body to specify signal and timeout.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesStopRequest
*/
func (a *MachinesAPIService) MachinesStop(ctx context.Context, appName string, machineId string) ApiMachinesStopRequest {
	return ApiMachinesStopRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesStopExecute(r ApiMachinesStopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesStop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesUncordonRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
}

func (r ApiMachinesUncordonRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesUncordonExecute(r)
}

/*
MachinesUncordon Uncordon Machine

“Cordoning” a Machine refers to disabling its services, so the Fly Proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of Machines is started up with services disabled, and when they are all healthy, the services are enabled on the new Machines and disabled on the old ones.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesUncordonRequest
*/
func (a *MachinesAPIService) MachinesUncordon(ctx context.Context, appName string, machineId string) ApiMachinesUncordonRequest {
	return ApiMachinesUncordonRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesUncordonExecute(r ApiMachinesUncordonRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesUncordon")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/uncordon"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesUpdateRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	request *UpdateMachineRequest
}

// Request body
func (r ApiMachinesUpdateRequest) Request(request UpdateMachineRequest) ApiMachinesUpdateRequest {
	r.request = &request
	return r
}

func (r ApiMachinesUpdateRequest) Execute() (*Machine, *http.Response, error) {
	return r.ApiService.MachinesUpdateExecute(r)
}

/*
MachinesUpdate Update Machine

Update a Machine's configuration using the details provided in the request body.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesUpdateRequest
*/
func (a *MachinesAPIService) MachinesUpdate(ctx context.Context, appName string, machineId string) ApiMachinesUpdateRequest {
	return ApiMachinesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return Machine
func (a *MachinesAPIService) MachinesUpdateExecute(r ApiMachinesUpdateRequest) (*Machine, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Machine
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMachinesUpdateMetadataRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	key string
}

func (r ApiMachinesUpdateMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesUpdateMetadataExecute(r)
}

/*
MachinesUpdateMetadata Update Metadata

Update metadata for a specific machine within an app by providing a metadata key.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @param key Metadata Key
 @return ApiMachinesUpdateMetadataRequest
*/
func (a *MachinesAPIService) MachinesUpdateMetadata(ctx context.Context, appName string, machineId string, key string) ApiMachinesUpdateMetadataRequest {
	return ApiMachinesUpdateMetadataRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
		key: key,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesUpdateMetadataExecute(r ApiMachinesUpdateMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesUpdateMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/metadata/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMachinesWaitRequest struct {
	ctx context.Context
	ApiService *MachinesAPIService
	appName string
	machineId string
	instanceId *string
	timeout *int32
	state *string
}

// instance? version? TODO
func (r ApiMachinesWaitRequest) InstanceId(instanceId string) ApiMachinesWaitRequest {
	r.instanceId = &instanceId
	return r
}

// wait timeout. default 60s
func (r ApiMachinesWaitRequest) Timeout(timeout int32) ApiMachinesWaitRequest {
	r.timeout = &timeout
	return r
}

// desired state
func (r ApiMachinesWaitRequest) State(state string) ApiMachinesWaitRequest {
	r.state = &state
	return r
}

func (r ApiMachinesWaitRequest) Execute() (*http.Response, error) {
	return r.ApiService.MachinesWaitExecute(r)
}

/*
MachinesWait Wait for State

Wait for a Machine to reach a specific state. Specify the desired state with the state parameter. See the [Machine states table](https://fly.io/docs/machines/working-with-machines/#machine-states) for a list of possible states. The default for this parameter is `started`.

This request will block for up to 60 seconds. Set a shorter timeout with the timeout parameter.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName Fly App Name
 @param machineId Machine ID
 @return ApiMachinesWaitRequest
*/
func (a *MachinesAPIService) MachinesWait(ctx context.Context, appName string, machineId string) ApiMachinesWaitRequest {
	return ApiMachinesWaitRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachinesAPIService) MachinesWaitExecute(r ApiMachinesWaitRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachinesAPIService.MachinesWait")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/{app_name}/machines/{machine_id}/wait"
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machine_id"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
